// Les fichiers hint permettent à l'IDE Visual Studio d'interpréter les identificateurs Visual C++
// tels que les noms de fonctions et de macros.
// Pour plus d'informations, consultez https://go.microsoft.com/fwlink/?linkid=865984
#define ENUMERATION(NAME, __VA_ARGS__) class NAME { public: enum class Enum : uint32_t { __VA_ARGS__, NotDefine }; private: uint32_t data; public: NAME() : data((uint32_t)NAME::Enum::NotDefine) {} NAME(NAME::Enum s) : data((uint32_t)s) {} NAME(uint32_t s) : data(s) {} bool operator==(const NAME& other) const { return data == other.data; } bool operator!=(const NAME& other) const { return data != other.data; } NAME operator|(NAME::Enum s) const { return NAME(data | (uint32_t)s); } NAME operator&(NAME::Enum s) const { return NAME(data & (uint32_t)s); } NAME& operator|=(NAME::Enum s) { data |= (uint32_t)s; return *this; } NAME& operator&=(NAME::Enum s) { data &= (uint32_t)s; return *this; } operator uint32_t() const { return data; } operator NAME::Enum() const { return (NAME::Enum)data; } bool Hasdata(NAME::Enum s) const { return (data & (uint32_t)s) != 0; } bool HasEnum(NAME::Enum s) const { return (data & (uint32_t)s) != 0; } std::string ToString() const { std::string str(""); NAME::ToStringImpl(str, data); return str == "" ? "NotDefine" : str; } static void ToStringImpl(std::string& str, uint32_t data) { (void)std::initializer_list<int>{((data & (uint32_t)NAME::Enum::__VA_ARGS__) ? (str += #__VA_ARGS__, 0) : "")...}; } friend std::ostream& operator<<(std::ostream& os, const NAME& e) { return os << e.ToString(); } friend std::string ToString(const NAME& v) { return v.ToString(); } };
